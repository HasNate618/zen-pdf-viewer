<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Zen PDF Viewer</title>
<style>
:root { color-scheme: dark; }
html, body {
  height: 100%;
  margin: 0;
  background: transparent;
  color: #dcfce7;
  font-family: "Inter", "JetBrainsMono Nerd Font", sans-serif;
  user-select: none;
  -webkit-user-select: none;
}
/* keyboard-only controls + improved overlays */
#viewerContainer {
  padding: 8px 8px 12px;
  user-select: none;
  -webkit-user-select: none;
}

#zenToast {
  position: fixed;
  bottom: 22px;
  left: 22px;
  display: flex;
  align-items: center;
  gap: 10px;
  background: rgba(18,17,17,0.88);
  color: #dcfce7;
  padding: 8px 12px;
  border-radius: 12px;
  border: 1px solid rgba(220,252,231,0.06);
  box-shadow: 0 8px 24px rgba(2,6,23,0.6);
  z-index: 1000;
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);
  font-size: 13px;
  max-width: min(420px, calc(100vw - 48px));
}
#zenToast .toast-content { display:flex; gap:8px; align-items:center; width:100%; }
#zenToast .toast-key { background: rgba(255,255,255,0.06); padding: 4px 8px; border-radius:6px; font-weight:600; font-family: monospace; }
#zenToast .toast-actions { margin-left:auto; display:flex; gap:8px; align-items:center; }
#zenToast label { font-size:13px; display:flex; align-items:center; gap:6px; color: #cdecd9; }
#zenToast button { background: transparent; border: 1px solid rgba(220,252,231,0.08); color: inherit; padding:5px 8px; border-radius:8px; cursor:pointer; }

.overlay { position: fixed; inset: 0; display:flex; align-items:center; justify-content:center; background: rgba(0,0,0,0.45); z-index:1001; }
.overlay[hidden] { display:none; }
.overlay-inner {
  position: relative;
  background: rgba(18,17,17,0.95);
  padding: 10px 12px;
  border-radius: 12px;
  width: min(960px, 92vw);
  max-height: 94vh;
  overflow:auto;
  border:1px solid rgba(220,252,231,0.06);
  box-shadow: 0 12px 40px rgba(2,6,23,0.6);
}
.overlay h2 { margin-top:0; margin-bottom:6px; font-size:15px; }
.keybinds-table { width: 100%; border-collapse: collapse; border-spacing: 0; table-layout: fixed; }
.keybinds-table td { padding: 3px 3px; border: none; vertical-align: top; }
.keybinds-table td:nth-child(1),
.keybinds-table td:nth-child(3) { width: 17%; white-space: nowrap; padding-right: 3px; }
.keybinds-table td:nth-child(2),
.keybinds-table td:nth-child(4) { width: 33%; padding-left: 3px; }
.keybinds-table td.empty { padding: 0; }
.keybinds-table .keybind-key { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', monospace; font-weight:600; color:#e6fff6; font-size:12.5px; white-space: nowrap; }
.keybinds-table .keybind-desc { color: #cfeee0; font-size:12.5px; line-height:1.25; }
.overlay .close { position:absolute; top:8px; right:8px; background:transparent; color: #cfeee0; border: 0; font-size:20px; cursor:pointer; padding:6px 8px; border-radius:6px; }
.overlay .close:hover { background: rgba(255,255,255,0.02); }


.zen-mode #viewerContainer {
  padding: 8px 0 54px;
  display: flex;
  flex-direction: column;
  gap: 4px;
  align-items: center;
}

.dual-mode #viewerContainer {
  padding: 8px 8px 12px;
  display: grid;
  grid-template-columns: repeat(2, minmax(0, max-content));
  gap: 8px;
  justify-content: center;
  justify-items: center;
  align-items: start;
  width: 100%;
}

.dual-mode .pageShell {
  margin: 0;
}
.pageShell {
  position: relative;
  margin: 14px auto;
  border-radius: 8px;
  overflow: hidden;
  background: transparent;
}

.zen-mode .pageShell {
  margin: 0;
  border-radius: 0;
}
.pageCanvas {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  background: transparent;
}
.textLayer {
  position: absolute;
  inset: 0;
  overflow: hidden;
  line-height: 1;
  text-size-adjust: none;
  forced-color-adjust: none;
  user-select: text;
  -webkit-user-select: text;
}
.textLayer span,
.textLayer br {
  color: transparent;
  position: absolute;
  white-space: pre;
  cursor: text;
  transform-origin: 0% 0%;
  user-select: text;
  -webkit-user-select: text;
}
.textLayer ::selection { background: rgba(74, 222, 127, 0.35); }
button,
input,
label { color: inherit; font: inherit; }
label {
  display: flex;
  align-items: center;
  gap: 4px;
  font-size: 12px;
}
button {
  background: rgba(18, 17, 17, 0.45);
  border: 1px solid rgba(220, 252, 231, 0.2);
  border-radius: 6px;
  padding: 4px 6px;
  cursor: pointer;
}
input[type="number"] {
  width: 50px;
  background: rgba(18, 17, 17, 0.45);
  border: 1px solid rgba(220, 252, 231, 0.2);
  border-radius: 6px;
  padding: 4px;
}
input[type="range"] { accent-color: #4ade7f; }
#error {
  margin: 90px auto 0;
  max-width: 720px;
  background: rgba(185, 28, 28, 0.2);
  border: 1px solid rgba(185, 28, 28, 0.5);
  border-radius: 10px;
  padding: 12px;
  display: none;
}
</style>
</head>
<body>
<div id="zenToast" hidden>
  <div class="toast-content">
    <span>Press Esc to open keybinds</span>
    <label><input id="toastDontShow" type="checkbox"> Don't show again</label>
    <button id="toastClose">OK</button>
  </div>
</div>

<div id="keybindsOverlay" class="overlay" hidden>
  <div class="overlay-inner">
    <button id="keybindsClose" class="close" aria-label="Close">×</button>
    <h2>Zen PDF Viewer — Keybindings</h2>
    <table id="keybindsText" class="keybinds-table" role="grid" aria-label="Keybindings">
      <tbody>
        <tr><td class="keybind-key">J, PgDn</td><td class="keybind-desc">Go to the next page</td></tr>
        <tr><td class="keybind-key">K, PgUp</td><td class="keybind-desc">Go to the previous page</td></tr>
        <tr><td class="keybind-key">h, j, k, l</td><td class="keybind-desc">Scroll left, down, up or right</td></tr>
        <tr><td class="keybind-key">Left, Down, Up, Right</td><td class="keybind-desc">Scroll left, down, up or right</td></tr>
        <tr><td class="keybind-key">^t, ^d, ^u, ^y</td><td class="keybind-desc">Scroll a half page left, down, up or right</td></tr>
        <tr><td class="keybind-key">space, b</td><td class="keybind-desc">Page down / page up</td></tr>
        <tr><td class="keybind-key">gg, G</td><td class="keybind-desc">Goto first or last page</td></tr>
        <tr><td class="keybind-key">P</td><td class="keybind-desc">Snap to the current page (center)</td></tr>
        <tr><td class="keybind-key">H, L</td><td class="keybind-desc">Goto top or bottom of the current page</td></tr>
        <tr><td class="keybind-key">^o, ^i</td><td class="keybind-desc">Move backward and forward through the jump list</td></tr>
        <tr><td class="keybind-key">Escape</td><td class="keybind-desc">Open/close keybinds viewer</td></tr>
        <tr><td class="keybind-key">/</td><td class="keybind-desc">Goto page number</td></tr>
        <tr><td class="keybind-key">r</td><td class="keybind-desc">Rotate by 90 degrees</td></tr>
        <tr><td class="keybind-key">z</td><td class="keybind-desc">Toggle Zen mode</td></tr>
        <tr><td class="keybind-key">c</td><td class="keybind-desc">Toggle color in Zen mode</td></tr>
        <tr><td class="keybind-key">R</td><td class="keybind-desc">Reload document</td></tr>
        <tr><td class="keybind-key">d</td><td class="keybind-desc">Toggle dual page view</td></tr>
        <tr><td class="keybind-key">F11</td><td class="keybind-desc">Toggle fullscreen mode</td></tr>
        <tr><td class="keybind-key">=, -</td><td class="keybind-desc">Zoom in / out</td></tr>
        <tr><td class="keybind-key">0</td><td class="keybind-desc">Reset zoom to 100%</td></tr>
        <tr><td class="keybind-key">q</td><td class="keybind-desc">Quit</td></tr>
      </tbody>
    </table>
    <div style="text-align:right; margin-top:8px"><button id="keybindsCloseBtn">Close</button></div>
  </div>
</div>
<div id="error"></div>
<div id="viewerContainer"></div>

<script src="https://unpkg.com/pdfjs-dist@2.16.105/build/pdf.min.js"></script>
<script>
(() => {
  const params = new URLSearchParams(location.search);
  const file = params.get("file") || "";
  const theme = {
    fg: params.get("fg") || "#e6e6e6",
    toolbarBg: params.get("bg") || "rgba(0,0,0,0.45)",
  };

  const state = {
    scale: 1,
    pdfDoc: null,
    zenMode: params.get("zen") !== "0",
    keepImagesColor: params.get("imgcolor") === "1",
    dualMode: params.get("dual") === "1",
    renderToken: 0,
  };

  const container = document.getElementById("viewerContainer");
  const errorEl = document.getElementById("error");
  const zoomInput = document.getElementById("zoom"); // optional (toolbar removed)
  const zenToast = document.getElementById("zenToast");
  const keybindsOverlay = document.getElementById("keybindsOverlay");
  const keybindsText = document.getElementById("keybindsText");
  const keybindsClose = document.getElementById("keybindsClose");
  const keybindsCloseBtn = document.getElementById("keybindsCloseBtn");

  // Apply theme and initial mode
  if (document.body) document.body.style.color = theme.fg;
  updateModeClass();

  // viewer state
  state.currentPage = 1;
  state.rotation = 0;
  state.jumpBack = [];
  state.jumpForward = [];
  state.pageCache = new Map();

  function clamp(v, min, max) {
    return Math.min(max, Math.max(min, v));
  }

  function showError(message) {
    errorEl.textContent = message;
    errorEl.style.display = "block";
  }

  function applyZenFilter(ctx, w, h, keepImagesColor) {
    const img = ctx.getImageData(0, 0, w, h);
    const d = img.data;
    for (let i = 0; i < d.length; i += 4) {
      const a = d[i + 3];
      if (a === 0) continue;

      const r = d[i];
      const g = d[i + 1];
      const b = d[i + 2];
      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      const chroma = max - min;
      const luma = 0.2126 * r + 0.7152 * g + 0.0722 * b;

      if (keepImagesColor && chroma > 36 && luma > 12 && luma < 244) {
        continue;
      }

      const gray = 0.299 * r + 0.587 * g + 0.114 * b;
      const inv = 255 - gray;
      if (inv < 4 && chroma < 6) {
        d[i + 3] = 0;
        continue;
      }
      d[i] = inv;
      d[i + 1] = inv;
      d[i + 2] = inv;
    }
    ctx.putImageData(img, 0, 0);
  }

  function updateModeClass() {
    if (state.zenMode) document.documentElement.classList.add("zen-mode");
    else document.documentElement.classList.remove("zen-mode");
    if (state.dualMode) document.documentElement.classList.add("dual-mode");
    else document.documentElement.classList.remove("dual-mode");
  }


  function compactKeybindsTable() {
    const table = document.getElementById('keybindsText');
    if (!table || table.dataset.compact === '1') return;
    const tbody = table.querySelector('tbody');
    if (!tbody) return;
    const items = [...tbody.querySelectorAll('tr')]
      .map((tr) => {
        const tds = tr.querySelectorAll('td');
        if (tds.length < 2) return null;
        return { key: tds[0].textContent.trim(), desc: tds[1].textContent.trim() };
      })
      .filter(Boolean);

    tbody.innerHTML = '';
    for (let i = 0; i < items.length; i += 2) {
      const a = items[i];
      const b = items[i + 1] || { key: '', desc: '' };
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td class="keybind-key">${a.key}</td>
        <td class="keybind-desc">${a.desc}</td>
        <td class="keybind-key ${b.key ? '' : 'empty'}">${b.key}</td>
        <td class="keybind-desc ${b.desc ? '' : 'empty'}">${b.desc}</td>`;
      tbody.appendChild(tr);
    }
    table.dataset.compact = '1';
  }

  function updateCurrentPageFromScroll() {
    if (!state.pdfDoc) return;
    const centerY = window.scrollY + window.innerHeight / 2;
    let best = state.currentPage || 1;
    let dist = Infinity;
    for (let i = 1; i <= state.pdfDoc.numPages; i++) {
      const el = document.getElementById(`page-${i}`);
      if (!el) continue;
      const pageCenter = el.offsetTop + el.offsetHeight / 2;
      const d = Math.abs(pageCenter - centerY);
      if (d < dist) { dist = d; best = i; }
    }
    state.currentPage = best;
  }

  async function renderTextLayer(page, viewport, textLayerDiv) {
    const textContent = await page.getTextContent();
    const textDivs = [];
    const task = pdfjsLib.renderTextLayer({
      textContent,
      textContentSource: textContent,
      container: textLayerDiv,
      viewport,
      textDivs,
      textContentItemsStr: [],
      enhanceTextSelection: true,
    });
    if (task?.promise) {
      await task.promise;
    } else {
      await task;
    }
  }

  async function getPdfPage(pageNumber) {
    if (state.pageCache.has(pageNumber)) return state.pageCache.get(pageNumber);
    const page = await state.pdfDoc.getPage(pageNumber);
    state.pageCache.set(pageNumber, page);
    return page;
  }

  function getOutputScale() {
    const dpr = Math.max(window.devicePixelRatio || 1, 1);
    const pages = state.pdfDoc?.numPages || 1;
    if (pages >= 120) return Math.min(dpr, 1.1);
    if (pages >= 60) return Math.min(dpr, 1.25);
    if (pages >= 30) return Math.min(dpr, 1.5);
    return Math.min(dpr, 2);
  }

  function buildRenderOrder(total, center) {
    const order = [center];
    for (let offset = 1; order.length < total; offset++) {
      const next = center + offset;
      const prev = center - offset;
      if (next <= total) order.push(next);
      if (prev >= 1) order.push(prev);
    }
    return order;
  }

  async function adjustScaleToMode() {
    if (!state.pdfDoc) return false;
    try {
      const firstPage = await getPdfPage(1);
      const vp = firstPage.getViewport({ scale: 1, rotation: (state.rotation || 0) });
      const pad = 16;
      const availableW = Math.max(100, window.innerWidth - pad);
      const availableH = Math.max(100, window.innerHeight - pad);
      let nextScale;

      if (state.dualMode) {
        const gap = 8;
        const totalWidth = (vp.width * 2) + gap;
        nextScale = availableW / Math.max(totalWidth, 1);
      } else {
        const scaleX = availableW / vp.width;
        const scaleY = availableH / vp.height;
        nextScale = Math.max(scaleX, scaleY);
      }

      const prevScale = state.scale;
      state.scale = Math.max(nextScale, 0.1);
      if (zoomInput) zoomInput.value = clamp(Math.round(state.scale * 100), 50, 250);
      return Math.abs(prevScale - state.scale) > 0.01;
    } catch (e) {
      return false;
    }
  }

  async function renderPage(pageNumber) {

    const page = await getPdfPage(pageNumber);
    const viewport = page.getViewport({ scale: state.scale, rotation: (state.rotation || 0) });

    const shell = document.createElement("div");
    shell.className = "pageShell";
    shell.id = `page-${pageNumber}`;
    shell.style.width = `${viewport.width}px`;
    shell.style.height = `${viewport.height}px`;

    const canvas = document.createElement("canvas");
    canvas.className = "pageCanvas";

    const textLayer = document.createElement("div");
    textLayer.className = "textLayer";

    shell.appendChild(canvas);
    shell.appendChild(textLayer);

    const outputScale = getOutputScale();
    canvas.width = Math.floor(viewport.width * outputScale);
    canvas.height = Math.floor(viewport.height * outputScale);

    const ctx = canvas.getContext("2d", {
      alpha: true,
      willReadFrequently: state.zenMode,
    });

    const renderParams = {
      canvasContext: ctx,
      viewport,
      background: state.zenMode ? "rgba(0,0,0,0)" : "rgb(255,255,255)",
      transform: outputScale !== 1 ? [outputScale, 0, 0, outputScale, 0, 0] : null,
    };

    await page.render(renderParams).promise;

    if (state.zenMode) {
      applyZenFilter(ctx, canvas.width, canvas.height, state.keepImagesColor);
    }

    await renderTextLayer(page, viewport, textLayer);
    return shell;
  }

  function getViewportAnchor() {
    if (!state.pdfDoc) return { page: state.currentPage || 1, ratio: 0.5 };
    const centerY = window.scrollY + window.innerHeight / 2;
    let page = state.currentPage || 1;
    let bestEl = null;
    let bestDist = Infinity;
    for (let i = 1; i <= state.pdfDoc.numPages; i++) {
      const el = document.getElementById(`page-${i}`);
      if (!el) continue;
      const pageCenter = el.offsetTop + el.offsetHeight / 2;
      const dist = Math.abs(pageCenter - centerY);
      if (dist < bestDist) {
        bestDist = dist;
        page = i;
        bestEl = el;
      }
    }
    if (!bestEl) return { page, ratio: 0.5 };
    const ratio = clamp((centerY - bestEl.offsetTop) / Math.max(bestEl.offsetHeight, 1), 0, 1);
    return { page, ratio };
  }

  function restoreViewportAnchor(anchor) {
    if (!anchor) return;
    const el = document.getElementById(`page-${anchor.page}`);
    if (!el) return;
    state.currentPage = anchor.page;
    const ratio = typeof anchor.ratio === "number" ? clamp(anchor.ratio, 0, 1) : 0.5;
    const targetCenter = el.offsetTop + (el.offsetHeight * ratio);
    window.scrollTo({ top: Math.max(0, targetCenter - (window.innerHeight / 2)), behavior: "auto" });
  }

  async function renderAll() {
    if (!state.pdfDoc) return;
    const token = ++state.renderToken;
    const anchor = getViewportAnchor();
    const total = state.pdfDoc.numPages;
    const center = clamp(anchor?.page || state.currentPage || 1, 1, total);
    const order = buildRenderOrder(total, center);
    let anchorRestored = false;

    for (const pageNo of order) {
      if (token !== state.renderToken) return;
      const pageNode = await renderPage(pageNo);
      if (token !== state.renderToken) return;

      const existing = document.getElementById(`page-${pageNo}`);
      if (existing && existing.parentNode === container) {
        container.replaceChild(pageNode, existing);
      } else {
        let inserted = false;
        for (let n = pageNo + 1; n <= total; n++) {
          const next = document.getElementById(`page-${n}`);
          if (next && next.parentNode === container) {
            container.insertBefore(pageNode, next);
            inserted = true;
            break;
          }
        }
        if (!inserted) container.appendChild(pageNode);
      }

      if (!anchorRestored && pageNo === center) {
        restoreViewportAnchor(anchor);
        anchorRestored = true;
      }
    }

    if (!anchorRestored) restoreViewportAnchor(anchor);
  }

  function goToPage(n, smooth = true, recordHistory = true) {
    const pageNo = clamp(Number.parseInt(n, 10) || 1, 1, state.pdfDoc?.numPages || 1);
    const el = document.getElementById(`page-${pageNo}`);
    if (!el) return;
    if (recordHistory && state.currentPage && state.currentPage !== pageNo) {
      state.jumpBack.push(state.currentPage);
      state.jumpForward = [];
    }
    state.currentPage = pageNo;
    window.scrollTo({ top: Math.max(0, el.offsetTop - 15), behavior: smooth ? "smooth" : "auto" });
  }

  function bindEvents() {
    // Toast handling (cookie-based so it persists even when localhost port changes)
    try {
      if (zenToast) {
        const getCookie = (name) => {
          if (!document.cookie) return '';
          const prefix = `${name}=`;
          const cookie = document.cookie.split(';').map(c => c.trim()).find((entry) => entry.startsWith(prefix));
          return cookie ? decodeURIComponent(cookie.slice(prefix.length)) : '';
        };
        const disabled = getCookie('zen_pdf_toast_disabled') === '1';
        if (!disabled) {
          zenToast.hidden = false;
          zenToast.style.display = 'flex';
        } else {
          zenToast.hidden = true;
          zenToast.style.display = 'none';
        }
        const toastCloseBtn = document.getElementById('toastClose');
        const toastDont = document.getElementById('toastDontShow');
        const closeToast = () => {
          if (toastDont && toastDont.checked) {
            try { document.cookie = 'zen_pdf_toast_disabled=1; path=/; max-age=31536000;'; } catch(e) { /* ignore */ }
          }
          zenToast.hidden = true;
          zenToast.style.display = 'none';
        };
        if (toastCloseBtn) {
          toastCloseBtn.addEventListener('click', closeToast);
          toastCloseBtn.addEventListener('pointerup', closeToast);
        }
      }
    } catch (e) { /* ignore */ }

    compactKeybindsTable();

    // keep current page synced while user scrolls
    let scrollTimer = null;
    window.addEventListener('scroll', () => {
      if (scrollTimer) clearTimeout(scrollTimer);
      scrollTimer = setTimeout(() => {
        scrollTimer = null;
        updateCurrentPageFromScroll();
      }, 100);
    }, { passive: true });

    // keybinds overlay close
    if (keybindsClose) keybindsClose.addEventListener('click', () => { if (keybindsOverlay) keybindsOverlay.hidden = true; });
    if (keybindsCloseBtn) keybindsCloseBtn.addEventListener('click', () => { if (keybindsOverlay) keybindsOverlay.hidden = true; });

    // helper functions
    let lastKey = null;
    let lastKeyTime = 0;
    let seqTimer = null;
    function setSeqTimer() { if (seqTimer) clearTimeout(seqTimer); seqTimer = setTimeout(() => { lastKey=null; seqTimer=null; }, 800); }

    // Improved selection handling: when dragging selection off-text, keep the last valid caret
    // so the selection endpoint doesn't jump back to the start of the document.
    let isPointerSelecting = false;
    let selectionAnchorRange = null;
    let lastValidCaretRange = null;
    let lastVisibleSelectionRange = null;
    let activePointerId = null;
    let activePointerTarget = null;

    function caretRangeFromPoint(x, y) {
      if (document.caretRangeFromPoint) return document.caretRangeFromPoint(x, y);
      if (document.caretPositionFromPoint) {
        const pos = document.caretPositionFromPoint(x, y);
        if (!pos) return null;
        const r = document.createRange();
        r.setStart(pos.offsetNode, pos.offset);
        r.setEnd(pos.offsetNode, pos.offset);
        return r;
      }
      return null;
    }

    function nodeIsInTextLayer(node) {
      if (!node) return false;
      const el = node.nodeType === Node.TEXT_NODE ? node.parentElement : node;
      return !!(el && el.closest && el.closest('.textLayer'));
    }

    function rangeIsInTextLayer(r) {
      if (!r) return false;
      return nodeIsInTextLayer(r.startContainer) && nodeIsInTextLayer(r.endContainer);
    }

    function eventTargetIsInTextLayer(target) {
      if (!target) return false;
      const el = target.nodeType === Node.TEXT_NODE ? target.parentElement : target;
      return !!(el && el.closest && el.closest('.textLayer'));
    }

    function cloneCollapsedRange(r) {
      if (!r) return null;
      const c = r.cloneRange ? r.cloneRange() : r;
      c.collapse(true);
      return c;
    }

    function restoreLastVisibleSelection() {
      if (!lastVisibleSelectionRange) return false;
      const sel = window.getSelection();
      if (!sel) return false;
      sel.removeAllRanges();
      sel.addRange(lastVisibleSelectionRange.cloneRange ? lastVisibleSelectionRange.cloneRange() : lastVisibleSelectionRange);
      return true;
    }

    function applyPointerSelection(anchorRange, focusRange) {
      if (!anchorRange || !focusRange) return false;
      const anchorNode = anchorRange.startContainer;
      const focusNode = focusRange.startContainer;
      if (!anchorNode || !focusNode || !anchorNode.isConnected || !focusNode.isConnected) return false;
      const sel = window.getSelection();
      if (!sel) return false;
      sel.removeAllRanges();
      if (sel.setBaseAndExtent) {
        sel.setBaseAndExtent(anchorNode, anchorRange.startOffset, focusNode, focusRange.startOffset);
      } else {
        const newRange = document.createRange();
        if (anchorRange.compareBoundaryPoints(Range.START_TO_START, focusRange) <= 0) {
          newRange.setStart(anchorNode, anchorRange.startOffset);
          newRange.setEnd(focusNode, focusRange.startOffset);
        } else {
          newRange.setStart(focusNode, focusRange.startOffset);
          newRange.setEnd(anchorNode, anchorRange.startOffset);
        }
        sel.addRange(newRange);
      }
      if (sel.rangeCount > 0) {
        const current = sel.getRangeAt(0);
        lastVisibleSelectionRange = current.cloneRange ? current.cloneRange() : current;
      }
      return true;
    }

    document.addEventListener('selectstart', (ev) => {
      if (eventTargetIsInTextLayer(ev.target)) return;
      if (isPointerSelecting) restoreLastVisibleSelection();
      ev.preventDefault();
    }, true);

    // Capture pointer-based selection start inside the textLayer
    document.addEventListener('pointerdown', (ev) => {
      if (ev.button !== 0) return;
      try {
        const r = caretRangeFromPoint(ev.clientX, ev.clientY);
        if (!r || !rangeIsInTextLayer(r)) return;
        isPointerSelecting = true;
        selectionAnchorRange = cloneCollapsedRange(r);
        lastValidCaretRange = cloneCollapsedRange(r);
        lastVisibleSelectionRange = null;
        activePointerId = ev.pointerId ?? null;
        activePointerTarget = ev.target || null;
        if (activePointerTarget && activePointerTarget.setPointerCapture && activePointerId !== null) {
          try { activePointerTarget.setPointerCapture(activePointerId); } catch (e) { /* ignore */ }
        }
        applyPointerSelection(selectionAnchorRange, lastValidCaretRange);
        ev.preventDefault();
      } catch(e) { /* ignore */ }
    }, true);

    // During pointer moves, keep the latest valid text endpoint and preserve visible selection
    // while dragging over non-text areas.
    document.addEventListener('pointermove', (ev) => {
      if (!isPointerSelecting) return;
      try {
        let focusRange = caretRangeFromPoint(ev.clientX, ev.clientY);
        if (focusRange && rangeIsInTextLayer(focusRange)) {
          lastValidCaretRange = cloneCollapsedRange(focusRange);
        } else {
          focusRange = lastValidCaretRange;
        }
        if (!selectionAnchorRange || !focusRange) {
          if (restoreLastVisibleSelection()) ev.preventDefault();
          return;
        }
        if (!applyPointerSelection(selectionAnchorRange, focusRange)) {
          if (restoreLastVisibleSelection()) ev.preventDefault();
          return;
        }
        ev.preventDefault();
      } catch (e) { /* ignore */ }
    }, true);

    document.addEventListener('pointerup', () => {
      if (isPointerSelecting) {
        if (activePointerTarget && activePointerTarget.releasePointerCapture && activePointerId !== null) {
          try { activePointerTarget.releasePointerCapture(activePointerId); } catch (e) { /* ignore */ }
        }
        isPointerSelecting = false;
        selectionAnchorRange = null;
        lastValidCaretRange = null;
        lastVisibleSelectionRange = null;
        activePointerId = null;
        activePointerTarget = null;
      }
    }, true);

    document.addEventListener('pointercancel', () => {
      if (activePointerTarget && activePointerTarget.releasePointerCapture && activePointerId !== null) {
        try { activePointerTarget.releasePointerCapture(activePointerId); } catch (e) { /* ignore */ }
      }
      isPointerSelecting = false;
      selectionAnchorRange = null;
      lastValidCaretRange = null;
      lastVisibleSelectionRange = null;
      activePointerId = null;
      activePointerTarget = null;
    }, true);

    function snapToNearestPage() {
      const centerY = window.scrollY + window.innerHeight/2;
      let best = 1;
      let bestDist = Infinity;
      for (let i=1;i<=state.pdfDoc.numPages;i++) {
        const el = document.getElementById('page-'+i);
        if (!el) continue;
        const top = el.offsetTop;
        const h = el.offsetHeight;
        const pageCenter = top + h/2;
        const d = Math.abs(pageCenter - centerY);
        if (d < bestDist) { bestDist = d; best = i; }
      }
      goToPage(best, true, false);
    }

    async function handleGotoPagePrompt() {
      const q = prompt('Goto page:');
      if (!q) return;
      const p = parseInt(q, 10);
      if (!Number.isNaN(p)) goToPage(p);
    }

    document.addEventListener('keydown', async (e) => {
      const active = document.activeElement && document.activeElement.tagName && document.activeElement.tagName.toLowerCase();
      if (active === 'input' || active === 'textarea') {
        if (e.key === 'Escape') document.activeElement.blur();
        return;
      }

      // Toggle keybind viewer on Escape
      if (e.key === 'Escape') {
        if (keybindsOverlay) keybindsOverlay.hidden = !keybindsOverlay.hidden;
        e.preventDefault();
        return;
      }

      // gg -> first page
      if (e.key === 'g') {
        const now = Date.now();
        if (lastKey === 'g' && (now - lastKeyTime) < 600) { goToPage(1); lastKey = null; setSeqTimer(); }
        else { lastKey = 'g'; lastKeyTime = now; setSeqTimer(); }
        e.preventDefault();
        return;
      }

      // G -> last page
      if (e.key === 'G') {
        goToPage(state.pdfDoc.numPages);
        e.preventDefault();
        return;
      }

      // Next/Prev page (uppercase J/K or PgDown/PgUp)
      if (e.key === 'J' || e.key === 'PageDown') { goToPage(state.currentPage + 1); e.preventDefault(); return; }
      if (e.key === 'K' || e.key === 'PageUp') { goToPage(state.currentPage - 1); e.preventDefault(); return; }

      // half-page scrolls with Ctrl (t,d,u,y)
      const halfY = Math.max(80, Math.floor(window.innerHeight * 0.45));
      const halfX = Math.max(80, Math.floor(window.innerWidth * 0.35));
      if (e.ctrlKey && e.key === 'd') { window.scrollBy({ top: halfY, behavior: 'smooth' }); e.preventDefault(); return; }
      if (e.ctrlKey && e.key === 'u') { window.scrollBy({ top: -halfY, behavior: 'smooth' }); e.preventDefault(); return; }
      if (e.ctrlKey && e.key === 't') { window.scrollBy({ left: -halfX, behavior: 'smooth' }); e.preventDefault(); return; }
      if (e.ctrlKey && e.key === 'y') { window.scrollBy({ left: halfX, behavior: 'smooth' }); e.preventDefault(); return; }

      // small scrolls (lowercase j/k/h/l)
      const small = Math.max(50, Math.floor(window.innerHeight * 0.12));
      if (e.key === 'j') { window.scrollBy({ top: small, behavior: 'smooth' }); e.preventDefault(); return; }
      if (e.key === 'k') { window.scrollBy({ top: -small, behavior: 'smooth' }); e.preventDefault(); return; }
      if (e.key === 'h') { window.scrollBy({ left: -small, behavior: 'smooth' }); e.preventDefault(); return; }
      if (e.key === 'l') { window.scrollBy({ left: small, behavior: 'smooth' }); e.preventDefault(); return; }

      // arrows
      if (e.key === 'ArrowDown') { window.scrollBy({ top: small, behavior: 'smooth' }); e.preventDefault(); return; }
      if (e.key === 'ArrowUp') { window.scrollBy({ top: -small, behavior: 'smooth' }); e.preventDefault(); return; }
      if (e.key === 'ArrowLeft') { window.scrollBy({ left: -small, behavior: 'smooth' }); e.preventDefault(); return; }
      if (e.key === 'ArrowRight') { window.scrollBy({ left: small, behavior: 'smooth' }); e.preventDefault(); return; }

      // page down/up via space/b
      if (e.key === ' ') { goToPage(state.currentPage + 1); e.preventDefault(); return; }
      if (e.key === 'b') { goToPage(state.currentPage - 1); e.preventDefault(); return; }

      // snap to nearest page (P)
      if (e.key === 'P') { snapToNearestPage(); e.preventDefault(); return; }

      // H/L top/bottom of current page
      if (e.key === 'H') { const el = document.getElementById('page-'+state.currentPage); if (el) window.scrollTo({ top: el.offsetTop, behavior: 'smooth' }); e.preventDefault(); return; }
      if (e.key === 'L') { const el = document.getElementById('page-'+state.currentPage); if (el) window.scrollTo({ top: el.offsetTop + el.offsetHeight - window.innerHeight + 16, behavior: 'smooth' }); e.preventDefault(); return; }

      // jump list Ctrl+o / Ctrl+i
      if (e.ctrlKey && e.key === 'o') { const p = state.jumpBack.pop(); if (p) { state.jumpForward.push(state.currentPage); goToPage(p, true, false); } e.preventDefault(); return; }
      if (e.ctrlKey && e.key === 'i') { const p = state.jumpForward.pop(); if (p) { state.jumpBack.push(state.currentPage); goToPage(p, true, false); } e.preventDefault(); return; }

      // rotate (r), zen toggle (z), and color toggle (c)
      if (e.key === 'r' && !e.ctrlKey) { state.rotation = (state.rotation + 90) % 360; await renderAll(); e.preventDefault(); return; }
      if (e.key === 'z') { state.zenMode = !state.zenMode; updateModeClass(); await renderAll(); e.preventDefault(); return; }
      if (e.key === 'c') { state.keepImagesColor = !state.keepImagesColor; await renderAll(); e.preventDefault(); return; }

      // dual-page mode toggle
      if (e.key === 'd') {
        const anchor = getViewportAnchor();
        state.dualMode = !state.dualMode;
        updateModeClass();
        await adjustScaleToMode();
        await renderAll();
        restoreViewportAnchor(anchor);
        e.preventDefault();
        return;
      }

      // reload
      if (e.key === 'R') { location.reload(); e.preventDefault(); return; }

      // fullscreen
      if (e.key === 'F11') { if (!document.fullscreenElement) document.documentElement.requestFullscreen().catch(()=>{}); else document.exitFullscreen().catch(()=>{}); e.preventDefault(); return; }

      // zoom = -
      if (e.key === '=') { state.scale = Math.min(state.scale * 1.1, 4); await renderAll(); e.preventDefault(); return; }
      if (e.key === '-') { state.scale = Math.max(state.scale / 1.1, 0.1); await renderAll(); e.preventDefault(); return; }
      if (e.key === '0') { state.scale = 1; await renderAll(); e.preventDefault(); return; }

      // goto page prompt
      if (e.key === '/') { handleGotoPagePrompt(); e.preventDefault(); return; }

      // quit
      if (e.key === 'q') { try { window.close(); } catch(err) { location.href='about:blank'; } e.preventDefault(); return; }

    });
  }

  async function init() {
    if (!file) {
      showError("No PDF file specified.");
      return;
    }

    try {
      pdfjsLib.GlobalWorkerOptions.workerSrc =
        "https://unpkg.com/pdfjs-dist@2.16.105/build/pdf.worker.min.js";

      state.pdfDoc = await pdfjsLib.getDocument({
        url: file,
        withCredentials: false,
      }).promise;

      bindEvents();

      function debounce(fn, wait) {
        let t = null;
        return (...args) => {
          if (t) clearTimeout(t);
          t = setTimeout(() => { t = null; fn(...args); }, wait);
        };
      }

      // Initial adjust and set resize handler to auto-fill on window changes.
      await adjustScaleToMode();
      const onResize = debounce(async () => { const changed = await adjustScaleToMode(); if (changed) await renderAll(); }, 180);
      window.addEventListener('resize', onResize);

      await renderAll();
    } catch (err) {
      showError(`Could not render PDF: ${err?.message || err}`);
      console.error(err);
    }
  }

  init();
})();
</script>
</body>
</html>
